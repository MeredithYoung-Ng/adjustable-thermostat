# adjustable-thermostat
Adjustable Thermostat that controls a 12V DC fan and a 7 segment display with a FRDM K64-F microcontroller. Also uses a LM34 temperature sensor and transistors.

# Introduction
Our final project for ECE 3140: Embedded Systems is an adjustable thermostat that controls a fan and 7 segment temperature display. Similar temperature controllers with real-time processes have many applications, especially in smart home technology. Many thermostats are able to control surrounding temperatures. Our thermostat uses a fan to help regulate the temperature measured by our temperature sensor, and uses a four digit 7 segment display to show the temperature at which the fan turns on as well as the temperature measured by our temperature sensor.   

High Level Design  
There are three major components, in addition to our FRDM K64F microcontroller: a LM34 temperature sensor, an ADDA AD4020-473514 fan, and a LD-4401AS seven segment display. To start running our thermostat, press '1' on the Putty terminal window. There are two main features for user interactivity–using the temperature sensor and setting the baseline fan temperature. Holding objects of different temperatures towards the temperature sensor changes the temperature read; the user can see the temperature display on the right two digits of our seven segment display and watch the fan adjust speed accordingly. By pressing the two buttons on the FRDM-K64F microcontroller (SW2 and SW3), the user adjusts the baseline fan temperature (the temperature at which the fan initially turns on). The temperatures for increased fan speeds then adjust accordingly (SW2 to increase, and SW3 to decrease the baseline fan temperature by 1°F). Note that the user can only adjust the baseline fan temperature between 0 and 99°F, as we only have two digits to display the baseline fan temperature on our seven segment display.

# Major Design Choices
System Priorities  
The temperature sensor (reading temperatures), the period for reading temperatures, the fan, and the two button switches on the microcontroller all use interrupts; our seven segment display uses polling. We decided to assign highest priority to the temperature sensor (and then period for reading temperatures) to ensure that our system has accurate temperature readings. This follows our design, in which the corresponding components react based on these temperature readings in real-time.  Of the remaining components that use interrupts, we decided that the fan is most important, as the fan speed is dependent on the temperature reading. Therefore, the fan gets third priority. Finally, the button switches have lowest priorities of the systems that utilize interrupts, and subsequently gets priority over the seven segment display. We decided that the seven segment display should utilize polling because it displays the temperature set by the button switches and the temperature read by the temperature sensor, and therefore needs this information in order to display accurately.   

Fan Controls  
We designed our system such that the fan speed is set right after the DAC is executed for the temperature sensor. We did this to prioritize the fan speed controls, as we want the fan speed to be set on the most recent temperature reading as possible. Note that if PIT0 and ADC interrupts become stacked (these interrupts are used for the temperature sensor readings), the performance of the real-time adjustment of the fan speed will be affected, as fan speed adjustments will be delayed.  

BJT Transistor  
We used a BJT to function as a switch because it has a small saturation range that can be reached with low voltage to the base. The BJT will stay in the saturation region for VBE = 650mV to 850mV. Since the emitter is grounded, we only need to account for the voltage applied to the base of the BJT. Thus, the microcontroller’s output voltage from DAC will control how much current flows through the BJT and the motor. We utilize the BJT because it is a simple design that doesn’t require more hardware components and allows us to control a 12v fan using very small voltage output from the microcontroller.  

Hardware/Software Trade-Offs  
One major hardware/software trade-off in our project is our usage of polling and interrupts. While interrupts are more CPU efficient for many aspects of our project, they are harder to implement (interrupt service routines needed) yet offer the priority based handling that we seek. In contrast, polling continually checks for updated values. Interrupts take priority over polling, so we found that using polling for the seven segment display enabled it to be the lowest priority as we intended. 
 
# Hardware Design  

Schematic Design  
We used a BJT to function as a switch because it has a small saturation range that can be reached with low voltage to the base. The BJT will stay in the saturation region for VBE = 650mV to 850mV. Since emitter is grounded, we only need to account for the voltage applied to the base of the BJT. Thus, the micro-controller's output voltage from DAC will control how much current flows through the BJT and the motor. We utilize the BJT because it is a simple design that doesn’t require more hardware components and allows us to control a 12v fan using very small voltage output from the micro-controller. We used a diode to protect the fan motor from back current when the fan turns off and changes in speed. We used a capacitor to ensure smoother transition between adjustments in fan speed by making sure that the voltage across the motor don’t change too fast. The diode and capacitor are used to prevent the motor from being wore out quickly.  

Tradeoffs  
One major tradeoff is the use of GPIO pins on the board in order to utilize the seven segment display. We needed a total of 11 pins from the microcontroller to fully control the display. The usage of this many pins means that the software implementation is very simple and efficient. This was an advantage because we had to configure the four digit seven segment display to the board and build our own library. The tradeoff is that we may not have 11 pins available on everyboard and that this limits the expansions we can do and peripherals to add on the microcontroller.  
 
# Software Design  

Protocols  
No additional protocols were needed to implement our project.     

Data Structures  
We have configuration structures to to set the configuration we wanted for the ADC and DAC. For ADC, we used default settings for the configuration and used a 16 bit resolution for the converter for more precise data. For the DAC, we also used default settings by setting low power mode to false and default reference voltage. We also have PIT structs for the setting of PIT, which simply contains whether the timer runs in debug mode.
We used a lot of global variables to help us implement our functions because our program needs to run continuously, depending on values such as average temperature, button state, and whether the button is pushed. It was simply easier to use global variables instead of using function parameters and pass by reference, because we don’t create new processes after initialization and when the program starts. Our global variables are also all volatile because our interrupts such as ADC and DAC uses and modifies them.  

Interrupt Priorities  
We set the interrupt priorities such that the temperature sensor (and then period for the temperature sensor readings) are the highest priority, to ensure that the rest of our real-time system is able to respond to accurate data readings. The fan is given a higher priority over the switches, as the fan is reliant on temperature data and the switches that control the baseline fan temperature are not as important.

Main Method  
Our main method (in main.c) starts by disabling all interrupts before interrupt initialization, and then mallocs space to store [digit], which stores the current values for each pin used to make a number on the seven segment display. We then initialize the hardware, ADC and DAC, PIT timers, buttons, and seven segment display. We use GETCHAR() so that the user can control when the project is started (by entering ‘1’) in the Putty terminal. We also set the interrupt priorities. Finally, we also have an infinite while loop that implements polling for the seven segment display.

Interrupt Handlers  
We used ADC0_IRQHandler, PIT0_IRQHandler, PIT1_IRQHandler, PIT2_IRQHandler, PORTC_IRQHandler, and NMI_Handler for our implementation. ADC0_IRQHandler is required for when the analog to digital conversion is complete and we can read the value. PIT0_IRQHandler handles the temperature sensor value sampling after a sampling period of approximately 0.5s. It enables the ADC0 interrupt and starts the ADC conversion. The interrupt also handles the averaging and getting rid of peaks and troughs. We also call the DAC right afterwards because it is important that the DAC updates the fan speed as soon as possible for fast reaction time to temperature changes. Having a long interrupt handler is ok in this case in that this process is the most important part of the program and takes up the majority of the computation time of the program. PIT1_IRQHandler and PIT2_IRQHandler are periodic timers for our button debouncing. This works by checking the button state every few intervals and operating a finite state machine. This works as a periodic scheduler that will ensure that each button press is registered only once. The NMI_Handler is for SW3, and PORTC_IRQHandler is for SW2 in the microcontroller. SW3 defaults to this exception and thus, we edit the interrupt handler to allow for button presses and controlling the temperature.

Conversion Algorithms  
We perform conversions from the temperature sensor data to generate the temperature values in degrees Fahrenheit. These conversions occur in PIT0_IRQHandler(), using helper functions found in converter.h and converter.c. removeMinMax(int * list, int size) removes the minimum and maximum temperature reading from this sampling (list) and averages the remaining values together to generate a more stabilized value for this reading. raw_to_temp(int raw) converts the temperature reading to Fahrenheit, as the temperature reading and degrees Fahrenheit are linearly related. In addition, we added a stabilization algorithm to PIT0_IRQHandler() to the baseline fan temperature threshold in order to delay the fan from turning on and off extremely quickly when the fan quickly fluctuates above and below the threshold, as this is bad for the fan motor. This algorithm smoothes out quick changes in temperature by keeping track of the previous two readings and making comparisons.

GPIO For Seven Segment Display  
To help keep our project more modular, we decided to implement helper functions to use GPIO for our seven segment display with seg_lib.h and seg_lib.c. Our seven segment display uses 11 GPIO pins. This involved using a global variable (int * digit) and global array (segments) containing the GPIO pin numbers. This enables us to save and access this information in the main loop for polling for the seven segment display. The main helper function used in main.c is a set_display() function which sets the seven segment display to a certain number specified by digit[0]. set_display() calls the other helper functions which reset/set [digit] to the digit we want to display (i.e. setZero() sets [digit] to 0).
The seven segment display consists of eight output pins that turns on a specific segment in the display as well as four digit pins that selects which digit to output. As the schematic shows, pins 1, 2, 3, 4, 5, 7, 10, and 11 are the segment pins that when put into high, will turn on that specific segment. We used a resistor between the GPIO and the pins because we have voltage from the GPIO and don’t want to short circuit the display. The digits display uses pins 6, 8, 9, 12 and will turn on when its pin is grounded, these don’t need resistors since they are grounded. We didn’t use pin 3 because we didn’t use the decimal point in our display. The resistor value we chose to place is around 300 Ohms, but can work up to 1000 Ohms. This allows enough current to flow through the display and allow the digits to light up brighter. Too small of a resistor could short out the display and blow it up. A deciding factor is that the board outputs 3.3V on logic 1.
For the GPIO pins, we directly set register values and used both PORTB and PORTD. PORTB’s register pins were abundantly available in our microcontroller so we decided use that for the segments and used PORTD for the digits. The ports are configured as GPIO pins and set as output. We can set the GPIO to logic 0 and logic 1. Logic 0 is effectively ground and and thus, if we want to turn on a digit, we clear the bit at that register holding the digit. If we want to turn on a segment, we write logic 1 to the relevant GPIO register.

Libraries Used  
We found that the ADC and DAC libraries for SDK available for download onto the FRDM K64F board were useful for implementing our temperature sensor. We wrote the rest of the code ourselves (including the seven segment display, as we created our own GPIO functions).
Things We Tried that Didn't Work
One problem we had was that the SW3 has NMI and has a very high priority by default. This results in the program being interrupted whenever we press and hold the button. SW3 has a different algorithm as opposed to SW2. Debouncing was also a problem we had to deal with in the program. Initially, we tried to debounce the program by inserting a for loop inside the interrupt, but this was unsuccessful. We eventually got SW3 to work by using a finite state machine to correctly implement debouncing.
 
# Testing
We tested incrementally throughout our project, making sure to throughly test after integrating each component. We found that this was quite effective as it helped us minimize the debugging needed to complete our project. The first milestone of our project was to get the fan speed to respond to a read temperature. We began by implementing the temperature sensor readings through ADC and DAC with the FRDM K64F microcontroller, and outputted these readings onto Putty for testing. To check that we were reading temperatures accurately, we compared these values printed out through Putty with measurements from a multimeter. Then, we implemented fan control by setting the fan speed based on different temperature boundary levels (i.e. turn off below 75°F, low speed between 75°F and 85°F, and high speed above 85°F). We then integrated these two components together, testing and debugging until this initial implementation worked. To test, we used various objects of different temperatures, as described in the Test Case section below. 
Upon completing our first milestone, we decided to add additional functionality to our project through the use of buttons on the microcontroller and a seven segment display to display the set fan temperature and current temperature. We wanted to incorporate a more active user input, so we began with setting up the button interaction. This button interaction adjusts the boundary at which the fan first turns on (increasing fan speed boundaries are increased in response as well). We then integrated this with our existing project, testing with our Test Case objects and viewing the output on Putty. Finally, we added another visualization to our project through the four digit seven segment display. We first wired our seven segment display and then tested it with a power source to ensure that this portion of our circuit was functioning properly. Then we wrote the corresponding GPIO code to control the seven segment display with our microcontroller. We then performed full system integration tests, using the same testing objects once again.  

Test Cases   

Fan (< 75°F)  
We held the fan near our temperature sensor (with the blades facing away from our project) to cool down the temperature sensor. This eventually brought the temperature down to below 75°F. Our baseline fan temperature is initialized to 75°F, so we were able to focus on testing the button switch functionality with this test case, as well as baseline fan temperature and our subsequent stabilizations.  

Human Hand (~82-85°F)    
Our hands were usually between 82 to 85°F. This was useful for testing the slower fan speeds, as the baseline fan temperature is initialized to 75°F. Using our hands and then switching to the fan and then reheating the temperature sensor with our hands was effective in testing the baseline fan temperature boundary.  

Heat Lamp (> 90°F)  
We tested our project under a heat lamp for brief time periods to test that our fan would stay on at higher temperatures. This was helpful for testing temperatures between 90°F and 99°F and the upper limit of our temperature project. We were unable to display numbers greater than 99°F on our seven segment display, so we set the upper limit to 99°F. 
 
# Results
Here is a video of our project: https://youtu.be/QOjk4-SLR5k
We successfully implemented our initial temperature controller design with the FRDM-K64F microcontroller, temperature sensor, and fan. We were able to find an analog temperature sensor, so we did not have to use any embedded bus protocols, which was an update from our original design. We were able to complete this milestone of our project with a few days left until the deadline; therefore, we decided to add the switch button interactivity and seven segment display as extensions onto our original design. 
Our fan responded correctly to the change in temperature and reliably and quickly updates the fan speed when temperature changes. Pressing the buttons adjusts the baseline temperature setting for the fan; the fan speed reacts to this as well. The display also changes very quickly and updates in real time.

# Conclusions
Overall, the thermostat worked as intended and contains all the features we hoped to integrate. The microcontroller correctly adjusted the fan speed based on temperature read from the temperature sensor input. Implementing the four digit seven segment display was the most challenging part of the project because of all the GPIO pins we had to use, in addition to accounting for the refresh rate of the display. The seven segment display can only show one number at a time for all four segments, so we had to quickly cycle through the numbers at a speed faster than the human eye can see. Additionally, we had to build the library for displaying the numbers on each segment from the ground up which involved a lot of coding. We were unable to make the number display more clear on the four digit seven segment display; this may be due to prior usage as we borrowed the display from a friend. This may be able to be improved by adding higher Ohm resistors to increase the voltage coming from the microcontroller. Moving forward, future hardware extensions would be allowing the user to set the aggressiveness of the fan on keeping the temperature in a certain value. On the software level, we would aim to make the seven segment display also use interrupts and instead poll user input where we potentially create a GUI for the user. This would reflect the functionality of a more advanced thermostat present in many homes and facilities.    

# References
State Diagram Code: http://people.ece.cornell.edu/land/courses/ece4760/labs/f2017/lab2_state_machine.txt  
ADC-DAC inspiration: https://github.com/UltimateHackingKeyboard/KSDK_2.0_FRDM-K22F/blob/master/boards/frdmk22f/demo_apps/dac_adc/dac_adc.c  
Peripherals  
ADC (for Temperature Sensor)  
DAC (for Temperature Sensor)  
SW2  
SW3  
LM34 Temperature Sensor  
GPIO (for Seven Segment Display)  
